{"title": "Recursive Neural Structural Correspondence Network for Cross-domain Aspect and Opinion Co-Extraction", "abstract": "Fine-grained opinion analysis aims to extract aspect and opinion terms from each sentence for opinion summarization. Supervised learning methods have proven to be effective for this task. However, in many domains, the lack of labeled data hinders the learning of a precise extraction model. In this case, unsupervised domain adaptation methods are desired to transfer knowledge from the source domain to any unlabeled target domain. In this paper, we develop a novel recursive neural network that could reduce domain shift effectively in word level through syntactic relations. We treat these relations as invariant \"pivot information\" across domains to build structural correspondences and generate an auxiliary task to predict the relation between any two adjacent words in the dependency tree. In the end, we demonstrate state-ofthe-art results on three benchmark datasets.", "text": [{"id": 0, "string": "Introduction The problem of fine-grained opinion analysis involves extraction of opinion targets (or aspect terms) and opinion expressions (or opinion terms) from each review sentence."}, {"id": 1, "string": "For example, in the sentence: \"They offer good appetizers\", the aspect and opinion terms are appetizers and good correspondingly."}, {"id": 2, "string": "Many supervised deep models have been proposed for this problem (Liu et al., 2015; Yin et al., 2016; Wang et al., 2017) , and obtained promising results."}, {"id": 3, "string": "However, these methods fail to adapt well across domains, because the aspect terms from two different domains are usually disjoint, e.g., laptop v.s."}, {"id": 4, "string": "restaurant, leading to large domain shift in the feature vector space."}, {"id": 5, "string": "Though unsupervised methods (Hu and Liu, 2004; Qiu et al., 2011) can deal with data with few labels, their performance is unsatisfactory compared with supervised ones."}, {"id": 6, "string": "There have been a number of domain adaptation methods for coarse-grained sentiment classification problems across domains, where an overall sentiment polarity of a sentence or document is being predicted."}, {"id": 7, "string": "Nevertheless, very few approaches exist for cross-domain fine-grained opinion analysis due to the difficulties in fine-grained adaptation, which is more challenging than coarse-grained problems."}, {"id": 8, "string": "Li et al."}, {"id": 9, "string": "(2012) proposed a bootstrap method based on the TrAdaBoost algorithm (Dai et al., 2007) to iteratively expand opinion and aspect lexicons in the target domain by exploiting source-domain labeled data and cross-domain common relations between aspect terms and opinion terms."}, {"id": 10, "string": "However, their model requires a seed opinion lexicon in the target domain and pre-mined syntactic patterns as a bridge."}, {"id": 11, "string": "Ding et al."}, {"id": 12, "string": "(2017) proposed to use rules to generate auxiliary supervision on top of a recurrent neural network to learn domain-invariant hidden representation for each word."}, {"id": 13, "string": "The performance highly depends on the quality of the manually defined rules and the prior knowledge of a sentiment lexicon."}, {"id": 14, "string": "In addition, the recurrent structure fails to capture the syntactic interactions among words intrinsically for opinion extraction."}, {"id": 15, "string": "The requirement for rules makes the above methods non-flexible."}, {"id": 16, "string": "In this paper, we propose a novel cross-domain Recursive Neural Network (RNN) 1 for aspect and opinion terms co-extraction across domains."}, {"id": 17, "string": "Our motivations are twofold: 1) The dependency relations capture the interactions among different words."}, {"id": 18, "string": "These relations are especially important for identifying aspect terms and opinion terms (Qiu et al., 2011; Wang et al., 2016) , which are also domain-invariant within the same language."}, {"id": 19, "string": "Therefore, they can be used as \"pivot\" information to bridge the gap between different domains."}, {"id": 20, "string": "2) Inspired by the idea of structural learning (Ando and Zhang, 2005) , the success of target task depends on the ability of finding good predictive structures learned from other related tasks, e.g., structural correspondence learning (SCL) (Blitzer et al., 2006) for coarse-grained cross-domain sentiment classification."}, {"id": 21, "string": "Here, we aim to generate an auxiliary task on dependency relation classification."}, {"id": 22, "string": "Different from previous approaches, our auxiliary task and the target extraction task are of heterogeneous label spaces."}, {"id": 23, "string": "We aim to integrate this auxiliary task with distributed relation representation learning into a recursive neural network."}, {"id": 24, "string": "Specifically, we generate a dependency tree for each sentence from the dependency parser and construct a unified RNN that integrates an auxiliary task into the computation of each node."}, {"id": 25, "string": "The auxiliary task is to classify the dependency relation for each direct edge in the dependency tree by learning a relation feature vector."}, {"id": 26, "string": "To reduce label noise brought by inaccurate parsing trees, we further propose to incorporate an autoencoder into the auxiliary task to group the relations into different clusters."}, {"id": 27, "string": "Finally, to model the sequential context interaction, we develop a joint architecture that combines RNN with a sequential labeling model for aspect and opinion terms extraction."}, {"id": 28, "string": "Extensive experiments are conducted to demonstrate the advantage of our proposed model."}, {"id": 29, "string": "Related Work Existing works for single-domain aspect/opinion terms extraction include unsupervised methods based on association rule mining (Hu and Liu, 2004) , syntactic rule propagation (Qiu et al., 2011) or topic modeling (Titov and McDonald, 2008; Lu et al., 2009; , as well as supervised methods based on extensive feature engineering with graphical models (Jin and Ho, 2009; Li et al., 2010) or deep learning (Liu et al., 2015; Zhang et al., 2015; Wang et al., 2017; Yin et al., 2016) ."}, {"id": 30, "string": "Among exiting deep models, improved results are obtained using dependency relations (Yin et al., 2016; Wang et al., 2016) , which indicates the significance of syntactic word interactions for target term extraction."}, {"id": 31, "string": "In cross-domain setting, there are very few works for aspect/opinion terms extraction including a pipelined approach (Li et al., 2012) and a recurrent neural network (Ding et al., 2017) ."}, {"id": 32, "string": "Both of the methods require manual construction of common and pivot syntactic patterns or rules, which are indicative of aspect or opinion words."}, {"id": 33, "string": "There have been a number of domain adaptation approaches proposed for coarse-grained sentiment classification."}, {"id": 34, "string": "Among existing methods, one active line focuses on projecting original feature spaces of two domains into the same low-dimensional space to reduce domain shift using pivot features as a bridge (Blitzer et al., 2007; Pan et al., 2010; Bollegala et al., 2015; Yu and Jiang, 2016 )."}, {"id": 35, "string": "Another line learns domain-invariant features via autoencoders (Glorot et al., 2011; Chen et al., 2012; ."}, {"id": 36, "string": "Our work is more related to the first line by utilizing pivot information to transfer knowledge across domains, but we integrate the idea into a unified deep structure that can fully utilize syntactic structure for domain adaptation in fine-grained sentiment analysis."}, {"id": 37, "string": "Problem Definition & Motivation Our task is to extract opinion and aspect terms within each review sentence."}, {"id": 38, "string": "We denote a sentence by a sequence of tokens x = (w 1 , w 2 , ..., w n )."}, {"id": 39, "string": "The output is a sequence of token-level labels y = (y 1 , y 2 , ..., y n ), with y i \u2208 {BA, IA, BO, IO, N} that represents beginning of an aspect (BA), inside of an aspect (IA), beginning of an opinion (BO), inside of an opinion (IO) or none of the above (N)."}, {"id": 40, "string": "A subsequence of labels started with \"BA\" and followed by \"IA\" indicates a multi-word aspect term."}, {"id": 41, "string": "In unsupervised domain adaptation, we are given a set of labeled review sentences from a source do- main D S = {(x S i , y S i )} n S i=1 , and a set of unlabeled sentences from a target domain D T = {x T j } n T j=1 ."}, {"id": 42, "string": "Our goal is to predict token-level labels on D T ."}, {"id": 43, "string": "Existing works for cross-domain aspect and/or opinion terms extraction require hand-coded rules and a sentiment lexicon in order to transfer knowledge across domains."}, {"id": 44, "string": "For example in Figure 1 , given a review sentence \"They offer good appetizers\" in the source domain and \"The laptop has a nice screen\" in the target domain."}, {"id": 45, "string": "If nice has been extracted as a common sentiment word, and \"OPINION-amod-ASPECT\" has been identified as a common syntactic pattern from the source domain, screen could be deduced as an aspect term using the identified syntactic pattern (Li et al., 2012) ."}, {"id": 46, "string": "Similarly, Ding et al."}, {"id": 47, "string": "(2017) used a set of predefined rules based on syntactic relations and a sentiment lexicon to generate auxiliary labels to learn high-level feature representations through a Figure 1 : An example of two reviews with similar syntactic patterns."}, {"id": 48, "string": "recurrent neural network."}, {"id": 49, "string": "On one hand, these previous attempts have verified that syntactic information between words, which can be used as a bridge between domains, is crucial for domain adaptation."}, {"id": 50, "string": "On the other hand, dependency-tree-based RNN (Socher et al., 2010) has proven to be effective to learn high-level feature representation of each word by encoding syntactic relations between aspect terms and opinion terms (Wang et al., 2016) ."}, {"id": 51, "string": "With the above findings, we propose a novel RNN named Recursive Neural Structural Correspondence Network (RNSCN) to learn high-level representation for each word across different domains."}, {"id": 52, "string": "Our model is built upon dependency trees generated from a dependency parser."}, {"id": 53, "string": "Different from previous approaches, we do not require any hand-coded rules or pre-selected pivot features to construct correspondences, but rather focus on the automatically generated dependency relations as the pivots."}, {"id": 54, "string": "The model associates each direct edge in the tree with a relation feature vector, which is used to predict the corresponding dependency relation as an auxiliary task."}, {"id": 55, "string": "Note that the relation vector is the key in the model: it associates with the two interacting words and is used to construct structural correspondences between two different domains."}, {"id": 56, "string": "Hence, the auxiliary task guides the learning of relation vectors, which in turn affects their correspondingly interactive words."}, {"id": 57, "string": "Specifically in Figure 1 , the relation vector for \"amod\" is computed from the features of its child and parent words, and also used to produce the hidden representation of its parent."}, {"id": 58, "string": "For this relation path in both sentences, the auxiliary task enforces close proximity for these two relation vectors."}, {"id": 59, "string": "This pushes the hidden representations for their parent nodes appetizers and screen closer to each other, provided that good and nice have similar representations."}, {"id": 60, "string": "In a word, the auxiliary task bridges the gap between two different domains by drawing the words with similar syntactic properties closer to each other."}, {"id": 61, "string": "However, the relation vectors may be sensitive to the accuracy of the dependency parser."}, {"id": 62, "string": "It might harm the learning process when some noise exists for certain relations, especially for informal texts."}, {"id": 63, "string": "This problem of noisy labels has been addressed using perceptual consistency (Reed et al., 2015) ."}, {"id": 64, "string": "Inspired by the taxonomy of dependency relations (de Marneffe and Manning, 2008) , relations with similar functionalities could be grouped together, e.g., dobj, iobj and pobj all indicate objects."}, {"id": 65, "string": "We propose to use an auto-encoder to automatically group these relations in an unsupervised manner."}, {"id": 66, "string": "The reconstruction loss serves as the consistency objective that reduces label noise by aligning relation features with their intrinsic relation group."}, {"id": 67, "string": "Proposed Methodology Our model consists of two components."}, {"id": 68, "string": "The first component is a Recursive Neural Structural Correspondence Network (RNSCN), and the second component is a sequence labeling classifier."}, {"id": 69, "string": "In this paper, we focus on Gated Recurrent Unit (GRU) as an implementation for the sequence labeling classifier."}, {"id": 70, "string": "We choose GRU because it is able to deal with long-term dependencies compared to a simple Recurrent neural network and requires less parameters making it easier to train than LSTM."}, {"id": 71, "string": "The resultant deep learning model is denoted by RNSCN-GRU."}, {"id": 72, "string": "We also implement Conditional Random Field as the sequence labeling classifier, and denote the model by RNSCN-CRF accordingly."}, {"id": 73, "string": "The overall architecture of RNSCN-GRU without auto-encoder on relation denoising is shown in Figure 2 ."}, {"id": 74, "string": "The left and right are two example sentences from the source and the target domain, respectively."}, {"id": 75, "string": "In the first component, RNSCN, an auxiliary task to predict the dependency relation for each direct edge is integrated into a dependencytree-based RNN."}, {"id": 76, "string": "We generate a relation vector for each direct edge from its child node to parent node, and use it to predict the relation and produce the hidden representation for the parent node in the dependency tree."}, {"id": 77, "string": "To address the issues of noisy relation labels, we further incorporate an auto-encoder into RNSCN, as will be shown in Figure 3 ."}, {"id": 78, "string": "While RNSCN mainly focuses on syntactic interactions among the words, the second component, GRU, aims to compute linear-context interactions."}, {"id": 79, "string": "GRU takes the hidden representation of each word computed from RNSCN as inputs and further produces final representation of each word by taking linear contexts into consideration."}, {"id": 80, "string": "We describe each component in detail in the following sections."}, {"id": 81, "string": "Recursive Neural Structural Correspondence Network RNSCN is built on the dependency tree of each sentence, which is pre-generated from a dependency parser."}, {"id": 82, "string": "Specifically, each node in the tree is associated with a word w n , an input word embedding x n \u2208 R d and a transformed hidden representation h n \u2208 R d ."}, {"id": 83, "string": "Each direct edge in the dependency tree associates with a relation feature vector r nm \u2208 R d and a true relation label vector y R nm \u2208 R K , where K is the total number of dependency relations, n and m denote the indices of the parent and child word of the dependency edge, respectively."}, {"id": 84, "string": "Based on the dependency tree, the hidden representations are generated in a recursive manner from leaf nodes until reaching the root node."}, {"id": 85, "string": "Consider the sourcedomain sentence shown in Figure 2 as an illustrative example, we first compute hidden representations for leaf nodes they and good: h 1 =tanh(W x x 1 + b), h 3 =tanh(W x x 3 + b), where W x \u2208 R d\u00d7d transforms word embeddings to hidden space."}, {"id": 86, "string": "For non-leaf node appetizer, we first generate the relation vector r 43 for the depen- dency edge x 4 (appetizers) amod \u2212 \u2212\u2212\u2212 \u2192 x 3 (good) by r 43 = tanh(W h h 3 + W x x 4 ), where W h \u2208 R d\u00d7d transforms the hidden representation to the relation vector space."}, {"id": 87, "string": "We then compute the hidden representation for appetizer: h 4 = tanh(W amod r 43 + W x x 4 + b)."}, {"id": 88, "string": "Moreover, the relation vector r 43 is used for the auxiliary task on relation prediction: y R 43 = softmax(W R r 43 + b R ), where W R \u2208 R K\u00d7d is the relation classifica- tion matrix."}, {"id": 89, "string": "The supervised relation classifier enforces close proximity of similar {r nm }'s in the distributed relation vector space."}, {"id": 90, "string": "The relation features bridge the gap of word representations in different domains by incorporating them into the forward computations."}, {"id": 91, "string": "In general, the hidden representation h n for a non-leaf node is produced through h n = tanh( m\u2208Mn W Rnm r nm + W x x n + b), (1) where r nm = tanh(W h \u00b7h m +W x \u00b7x n ), M n is the set of child nodes of w n , and W Rnm is the relation transformation matrix tied with each relation R nm ."}, {"id": 92, "string": "The predicted label vector\u0177 R nm for r nm i\u015d y R nm = softmax(W R \u00b7 r nm + b R )."}, {"id": 93, "string": "(2) Here we adopt the the cross-entropy loss for relation classification between the predicted label vector\u0177 R nm and the ground-truth y R nm to encode relation side information into feature learning: R = K k=1 \u2212y R nm[k] log\u0177 R nm[k] ."}, {"id": 94, "string": "(3) Through the auxiliary task, similar relations enforce participating words close to each other so that words with similar syntactic functionalities are clustered across domains."}, {"id": 95, "string": "On the other hand, the pre-trained word embeddings group semanticallysimilar words."}, {"id": 96, "string": "By taking them as input to RNN, together with the auxiliary task, our model encodes both semantic and syntactic information."}, {"id": 97, "string": "Reduce Label Noise with Auto-encoders As discussed in Section 3, it might be hard to learn an accurate relation classifier when each class is a unique relation, because the dependency parser may generate incorrect relations as noisy labels."}, {"id": 98, "string": "To address it, we propose to integrate an autoencoder into RNSCN."}, {"id": 99, "string": "Suppose there is a set of latent groups of relations: G = {1, 2, ..., |G|}, where each relation belongs to only one group."}, {"id": 100, "string": "For each relation vector, r nm , an autoencoder is performed before feeding it into the auxiliary classifier (2)."}, {"id": 101, "string": "The goal is to encode the relation vector to a probability distribution of assigning this relation to any group."}, {"id": 102, "string": "As can be seen Figure 3 , each relation vector r nm is first passed through the autoencoder as follows, p(G nm = i|r nm ) = exp(r nm W enc g i ) j\u2208G exp(r nm W enc g j ) , (4) where G nm denotes the inherent relation group for r nm , g i \u2208 R d represents the feature embedding for group i, and W enc \u2208R d\u00d7d is the encoding matrix that computes bilinear interactions between relation vector r nm and relation group embedding g i ."}, {"id": 103, "string": "Thus, p(G nm = i|r nm ) represents the probability of r nm being mapped to group i."}, {"id": 104, "string": "An accumulated relation group embedding is computed as: g nm = |G| i=1 p(G nm = i|r nm )g i ."}, {"id": 105, "string": "(5) For decoding, the decoder takes g nm as input and tries to reconstruct the relation feature input r nm ."}, {"id": 106, "string": "Moreover, g nm is also used as the higher-level feature vector for r nm for predicting the relation label."}, {"id": 107, "string": "Therefore, the objective for the auxiliary task in (3) becomes: R = R 1 + \u03b1 R 2 + \u03b2 R 3 , (6) where  Here R 1 is the reconstruction loss with W dec being the decoding matrix, R 2 follows (3) wit\u0125 y R nm = softmax(W R g nm + b R ) and R 3 is the regularization term on the correlations among latent groups with I being the identity matrix and\u1e20 being a normalized group embedding matrix that consists of normalized g i 's as column vectors."}, {"id": 108, "string": "This regularization term enforces orthogonality between g i and g j for i = j. \u03b1 and \u03b2 are used to control the trade-off among different losses."}, {"id": 109, "string": "With the auto-encoder, the auxiliary task of relation classification is conditioned on group assignment."}, {"id": 110, "string": "The reconstruction loss further ensures the consistency between relation features and groupings, which is supposed to dominate classification loss when the observed labels are inaccurate."}, {"id": 111, "string": "We denote RNSCN with auto-encoder by RNSCN + ."}, {"id": 112, "string": "R 1 = r nm \u2212 W dec g nm 2 2 , (7) R 2 = K k=1 \u2212y R nm[k] log\u0177 R nm[k] , (8) R 3 = I \u2212\u1e20 \u1e20 2 F ."}, {"id": 113, "string": "(9) Joint Models for Sequence Labeling RNSCN or RNSCN + focuses on capturing and representing syntactic relations to build a bridge between domains and learn more powerful representations for tokens."}, {"id": 114, "string": "However, it ignores the linearchain correlations among tokens within a sentence, which is important for aspect and opinion terms extraction."}, {"id": 115, "string": "Therefore, we propose a joint model, denoted by RNSCN-GRU (RNSCN + -GRU), which integrates a GRU-based recurrent neural network on top of RNSCN (RNSCN + ), i.e., the input for GRU is the hidden representations h n learned by RNSCN or RNSCN + for the n-th token in the sentence."}, {"id": 116, "string": "For simplicity in presentation, we denote the computation of GRU by using the notation f GRU ."}, {"id": 117, "string": "To be specific, by taking h n as input, the final feature representation h n for each word is obtained through h n = f GRU (h n\u22121 , h n ; \u0398), (10) where \u0398 is the collection of the GRU parameters."}, {"id": 118, "string": "The final token-level prediction is made throug\u0125 y n = softmax(W l \u00b7 h n + b l ), (11) where W l \u2208 R 5\u00d7d transforms a d -dimensional feature vector to class probabilities (note that we have 5 different classes as defined in Section 3)."}, {"id": 119, "string": "The second joint model, namely RNSCN-CRF, combines a linear-chain CRF with RNSCN to learn the discriminative mapping from high-level features to labels."}, {"id": 120, "string": "The advantage of CRF is to learn sequential interactions between each pair of adjacent words as well as labels and provide structural outputs."}, {"id": 121, "string": "Formally, the joint model aims to output a sequence of labels with maximum conditional probability given its input."}, {"id": 122, "string": "Denote by y a sequence of labels for a sentence and by H the embedding matrix for each sentence (each column denotes a hidden feature vector of a word in the sentence learned by RNSCN), the inference is computed as: y= arg max y p(y|H) = arg max y 1 Z(H) c\u2208C exp W c , g(H, y c ) (12) where C indicates the set of different cliques (unary and pairwise cliques in the context of linear-chain)."}, {"id": 123, "string": "W c is tied for each different y c , which indicates the labels for clique c. The operator \u00b7, \u00b7 is the element-wise multiplication, and g(\u00b7) produces the concatenation of {h n }'s in a context window of each word."}, {"id": 124, "string": "The above two models both consider the sequential interaction of the words within each sentence, but the formalization and training are totally different."}, {"id": 125, "string": "We will report the results for both joint models in the experiment section."}, {"id": 126, "string": "Training Recall that in our cross-domain setting, the labels for terms extraction are only available in the source domain, but the auxiliary relation labels can be automatically produced for both domains via the dependency parser."}, {"id": 127, "string": "Besides the source domain labeled data D S = {(x S i , y S i )} n S i=1 , we denote by D R = {(r j , y R j )} n R j=1 the combined source and target domain data with auxiliary relation labels."}, {"id": 128, "string": "For training, the total loss consists of token-prediction loss S and relation-prediction loss R : L = D S S (y S i ,\u0177 S i ) + \u03b3 D R R (r j , y R j ), (13) where \u03b3 is the trade-off parameter, S is the crossentropy loss between the predicted extraction label in (11) and the ground-truth, and R is defined in (6) for RNSCN + or (3) for RNSCN."}, {"id": 129, "string": "For RNSCN-CRF, the loss becomes the negative log probability of the true label given the corresponding input:  The parameters for token-level predictions and relation-level predictions are updated jointly such that the information from the auxiliary task could be propagated to the target task to obtain better performance."}, {"id": 130, "string": "This idea is in accordance with structural learning proposed by Ando and Zhang (2005) , which shows that multiple related tasks are useful for finding the optimal hypothesis space."}, {"id": 131, "string": "In our case, the set of multiple tasks includes the target terms extraction task and the auxiliary relation prediction task, which are closely related."}, {"id": 132, "string": "The parameters are all shared across domains."}, {"id": 133, "string": "The joint model is trained using back-propagation from the top layer of GRU or CRF to RNSCN until reaching to the input word embeddings in the bottom."}, {"id": 134, "string": "S (y S i ,\u0177 S i ) = \u2212 log(y S i |h S i )."}, {"id": 135, "string": "(14) Experiments Data & Experimental Setup The data is taken from the benchmark customer reviews in three different domains, namely restaurant, laptop and digital devices."}, {"id": 136, "string": "The restaurant domain contains a combination of restaurant reviews from SemEval 2014 task 4 subtask 1 (Pontiki et al., 2014) and SemEval 2015 task 12 subtask 1 (Pontiki et al., 2015) ."}, {"id": 137, "string": "The laptop domain consists of laptop reviews from SemEval 2014 task 4 subtask 1."}, {"id": 138, "string": "For digital device, we take reviews from (Hu and Liu, 2004) containing sentences from 5 digital devices."}, {"id": 139, "string": "The statistics for each domain are shown in Table 1 ."}, {"id": 140, "string": "In our experiments, we randomly split the data in each domain into training set and testing set with the proportion being 3:1."}, {"id": 141, "string": "To obtain more rigorous result, we make three random splits for each domain and test the learned model on each split."}, {"id": 142, "string": "The number of sentences for training and testing after each split is also shown in Table 1 ."}, {"id": 143, "string": "Each sentence is labeled with aspect terms and opinion terms."}, {"id": 144, "string": "For each cross-domain task, we conduct both inductive and transductive experiments."}, {"id": 145, "string": "Specifically, we train our model only on the training sets from both (labeled) source and (unlabeled) target domains."}, {"id": 146, "string": "For testing, the inductive results are obtained using the test data from the target domain, and the transductive results are obtained using the (unlabeled) training data from the target domain."}, {"id": 147, "string": "The evaluation metric we used is F1 score."}, {"id": 148, "string": "Following the setting from existing work, only exact match could be counted as correct."}, {"id": 149, "string": "For experimental setup, we use Stanford Dependency Parser (Klein and Manning, 2003) to generate dependency trees."}, {"id": 150, "string": "There are in total 43 different dependency relations, i.e."}, {"id": 151, "string": "43 classes for the auxiliary task."}, {"id": 152, "string": "We set the number of latent relation groups as 20."}, {"id": 153, "string": "The input word features for RNSCN are pre-trained word embeddings using word2vec (Mikolov et al., 2013) which is trained on 3M reviews from the Yelp dataset 2 and electronics dataset in Amazon reviews 3 (McAuley et al., 2015) ."}, {"id": 154, "string": "The dimension of word embeddings is 100."}, {"id": 155, "string": "Because of the relatively small size of the training data compared with the number of parameters, we firstly pre-train RNSCN for 5 epochs with minibatch size 30 and rmsprop initialized at 0.01."}, {"id": 156, "string": "The joint model of RNSCN + -GRU is then trained with rmsprop initialized at 0.001 and mini-batch size 30."}, {"id": 157, "string": "The trade-off parameter \u03b1, \u03b2 and \u03b3 are set to be 1, 0.001 and 0.1, respectively."}, {"id": 158, "string": "The hidden-layer dimension for GRU is 50, and the context window size is 3 for input feature vectors of GRU."}, {"id": 159, "string": "For the joint model of RNSCN-CRF, we implement SGD with a decaying learning rate initialized at 0.02."}, {"id": 160, "string": "The context window size is also 3 in this case."}, {"id": 161, "string": "Both joint models are trained for 10 epochs."}, {"id": 162, "string": "Comparison & Results We compared our proposed model with several baselines and variants of the proposed model: \u2022 RNCRF: A joint model of recursive neural network and CRF proposed by (Wang et al., 2016) for single-domain aspect and opinion terms extraction."}, {"id": 163, "string": "We make all the parameters shared across domains for target prediction."}, {"id": 164, "string": "\u2022 RNGRU: A joint model of RNN and GRU."}, {"id": 165, "string": "The hidden layer of RNN is taken as input for GRU."}, {"id": 166, "string": "We share all the parameters across domains, similar to RNCRF."}, {"id": 167, "string": "\u2022 CrossCRF: A linear-chain CRF with handengineered features that are useful for crossdomain settings (Jakob and Gurevych, 2010) , e.g., POS tags, dependency relations."}, {"id": 168, "string": "\u2022 RAP: The Relational Adaptive bootstraPping method proposed by (Li et al., 2012) that uses TrAdaBoost to expand lexicons."}, {"id": 169, "string": "\u2022 Hier-Joint: A recent deep model proposed by Ding et al."}, {"id": 170, "string": "(2017) that achieves state-ofthe-art performance on aspect terms extraction across domains."}, {"id": 171, "string": "\u2022 RNSCN-GRU: Our proposed joint model integrating auxiliary relation prediction task into RNN that is further combined with GRU."}, {"id": 172, "string": "\u2022 RNSCN-CRF: The second proposed model similar to RNSCN-GRU, which replace GRU with CRF."}, {"id": 173, "string": "\u2022 RNSCN + -GRU: Our final joint model with auto-encoders to reduce auxiliary label noise."}, {"id": 174, "string": "Note that we do not implement other recent deep adaptation models for comparison (Chen et al., 2012; Yang and Hospedales, 2015) , because Hier-Joint (Ding et al., 2017) has already demonstrated better performances than these models."}, {"id": 175, "string": "The overall comparison results with the baselines are shown in Table 2 with average F1 scores and standard deviations over three random splits."}, {"id": 176, "string": "Clearly, the results for aspect terms (AS) transfer are much lower than opinion terms (OP) transfer, which indicate that the aspect terms are usually quite different across domains, whereas the opinion terms could be more common and similar."}, {"id": 177, "string": "Hence the ability to adapt the aspect extraction from the source domain to the target domain becomes more crucial."}, {"id": 178, "string": "On this behalf, our proposed model shows clear advantage over other baselines for this more difficult transfer problem."}, {"id": 179, "string": "Specifically, we achieve 6.77%, 5.88%, 10.55% improvement over the bestperforming baselines for aspect extraction in R\u2192L, L\u2192D and D\u2192L, respectively."}, {"id": 180, "string": "By comparing with RNCRF and RNGRU, we show that the structural correspondence network is indeed effective when integrated into RNN."}, {"id": 181, "string": "To show the effect of the integration of the autoencoder, we conduct experiments over different variants of the proposed model in Table 3 ."}, {"id": 182, "string": "RNSCN-GRU represents the model without autoencoder, which achieves much better F1 scores on most experiments compared with the baselines in Table 2 ."}, {"id": 183, "string": "RNSCN + -GRU outperforms RNSCN-GRU in almost all experiments."}, {"id": 184, "string": "This indicates the autoencoder automatically learns data-dependent groupings, which is able to reduce unnecessary label noise."}, {"id": 185, "string": "To further verify that the autoencoder indeed reduces label noise when the parser is inaccurate, we generate new noisy parse trees by replacing some relations within each sentence with a random    relation."}, {"id": 186, "string": "Specifically, in each source domain, for each relation that connects to any aspect or opinion word, it has 0.5 probability of being replaced by any other relation."}, {"id": 187, "string": "In Table 3 , We denote the model with noisy relations with (r)."}, {"id": 188, "string": "Obviously, the performance of RNSCN-GRU without an autoencoder significantly deteriorates when the auxiliary labels are very noisy."}, {"id": 189, "string": "On the contrary, RNSCN + -GRU (r) achieves acceptable results compared to RNSCN + -GRU."}, {"id": 190, "string": "This proves that the autoencoder makes the model more robust to label noise and helps to adapt the information more accurately to the target data."}, {"id": 191, "string": "Note that a large drop for L \u2192 R in aspect extraction might be caused by a large portion of noisy replacements for this particular data which makes it too hard to train a good classifier."}, {"id": 192, "string": "This may not greatly influence opinion extraction, as shown, because the two domains usually share many common opinion terms."}, {"id": 193, "string": "However, the significant difference in aspect terms makes the learning more dependent on common relations."}, {"id": 194, "string": "The above comparisons are made using the test data from target domains which are not available during training (i.e., the inductive setting)."}, {"id": 195, "string": "For more complete comparison, we also conduct experiments in the transductive setting."}, {"id": 196, "string": "We pick our best model RNSCN + -GRU, and show the effect of different components."}, {"id": 197, "string": "To do that, we first remove the sequential structure on top, resulting in RNSCN + ."}, {"id": 198, "string": "Moreover, we create another variant by removing opinion term labels to show the effect of the double propogation between aspect terms and opinion terms."}, {"id": 199, "string": "The resulting model is named RNSCN + -GRU*."}, {"id": 200, "string": "As shown in Table 4 , we denote by OUT and IN the inductive and transductive setting, respectively."}, {"id": 201, "string": "The results shown are the average F1 scores among three splits 4 ."}, {"id": 202, "string": "In general, RNSCN + -GRU shows similar performances for both inductive and transductive settings."}, {"id": 203, "string": "This indicates the is, are, feels, believes, seems, like, will, would Table 5 : Case studies on word clustering robustness and the ability to learn well when test data is not presented during training."}, {"id": 204, "string": "Without opinion labels, RNSCN + -GRU* still achieves better results than Hier-Joint most of the time."}, {"id": 205, "string": "Its lower performance compared to RNSCN + -GRU also indicates that in the cross-domain setting, the dual information between aspects and opinions is beneficial to find appropriate and discriminative relation feature space."}, {"id": 206, "string": "Finally, the results for RNSCN + by removing GRU are lower than the joint model, which proves the importance of combining syntactic tree structure with sequential modeling."}, {"id": 207, "string": "To qualitatively show the effect of the auxiliary task with auto-encoders for clustering syntactically similar words across domains, we provide some case studies on the predicted groups of some words in Table 5 ."}, {"id": 208, "string": "Specifically, for each relation in the dependency tree, we use (4) to obtain the most probable group to assign the word in the child node."}, {"id": 209, "string": "The left column shows the predicted group index with the right column showing the corresponding words."}, {"id": 210, "string": "Clearly, the words in the same group have similar syntactic functionalities, whereas the word types vary across groups."}, {"id": 211, "string": "In the end, we verify the robustness and capability of the model by conducting sensitivity studies and experiments with varying number of unlabeled target data for training, respectively."}, {"id": 212, "string": "Figure 4 shows the sensitivity test for L\u2192D, which indicates that changing of the trade-off parameter \u03b3 or the number of groups |G| does not affect the model's performance greatly, i.e., less than 1% for aspect extraction and 2% for opinion extraction."}, {"id": 213, "string": "This proves that our model is robust and stable against small variations."}, {"id": 214, "string": "Figure 5 compares the results of RNSCN + -GRU with Hier-Joint when increasing the proportion of unlabeled target training data from 0 to 1."}, {"id": 215, "string": "Obviously, our model shows steady improvement with the increasing number of unlabeled target data."}, {"id": 216, "string": "This pattern proves our Conclusion We propose a novel dependency-tree-based RNN, namely RNSCN (or RNSCN + ), for domain adaptation."}, {"id": 217, "string": "The model integrates an auxiliary task into representation learning of nodes in the dependency tree."}, {"id": 218, "string": "The adaptation takes place in a common relation feature space, which builds the structural correspondences using syntactic relations among the words in each sentence."}, {"id": 219, "string": "We further develop a joint model to combine RNSCN/RNSCN + with a sequential labeling model for terms extraction."}], "headers": [{"section": "Introduction", "n": "1", "start": 0, "end": 28}, {"section": "Related Work", "n": "2", "start": 29, "end": 36}, {"section": "Problem Definition & Motivation", "n": "3", "start": 37, "end": 66}, {"section": "Proposed Methodology", "n": "4", "start": 67, "end": 80}, {"section": "Recursive Neural Structural Correspondence Network", "n": "4.1", "start": 81, "end": 96}, {"section": "Reduce Label Noise with Auto-encoders", "n": "4.2", "start": 97, "end": 112}, {"section": "Joint Models for Sequence Labeling", "n": "4.3", "start": 113, "end": 125}, {"section": "Training", "n": "4.4", "start": 126, "end": 134}, {"section": "Data & Experimental Setup", "n": "5.1", "start": 135, "end": 161}, {"section": "Comparison & Results", "n": "5.2", "start": 162, "end": 215}, {"section": "Conclusion", "n": "6", "start": 216, "end": 219}], "figures": [{"filename": "../figure/image/952-Table1-1.png", "caption": "Table 1: Data statistics with number of sentences.", "page": 5, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 63.839999999999996, "y2": 112.32}}, {"filename": "../figure/image/952-Figure1-1.png", "caption": "Figure 1: An example of two reviews with similar syntactic patterns.", "page": 2, "bbox": {"x1": 72.0, "x2": 291.36, "y1": 62.879999999999995, "y2": 120.96}}, {"filename": "../figure/image/952-Table4-1.png", "caption": "Table 4: Comparisons with different transfer setting.", "page": 7, "bbox": {"x1": 85.92, "x2": 511.2, "y1": 347.52, "y2": 437.28}}, {"filename": "../figure/image/952-Table2-1.png", "caption": "Table 2: Comparisons with different baselines.", "page": 7, "bbox": {"x1": 92.64, "x2": 504.0, "y1": 62.879999999999995, "y2": 213.12}}, {"filename": "../figure/image/952-Table3-1.png", "caption": "Table 3: Comparisons with different variants of the proposed model.", "page": 7, "bbox": {"x1": 96.96, "x2": 501.12, "y1": 252.48, "y2": 308.15999999999997}}, {"filename": "../figure/image/952-Figure2-1.png", "caption": "Figure 2: The architecture of RNSCN-GRU.", "page": 3, "bbox": {"x1": 103.67999999999999, "x2": 490.08, "y1": 62.879999999999995, "y2": 309.12}}, {"filename": "../figure/image/952-Figure4-1.png", "caption": "Figure 4: Sensitivity studies for L\u2192D.", "page": 8, "bbox": {"x1": 309.59999999999997, "x2": 517.4399999999999, "y1": 70.08, "y2": 171.35999999999999}}, {"filename": "../figure/image/952-Figure5-1.png", "caption": "Figure 5: F1 vs proportion of unlabeled target data.", "page": 8, "bbox": {"x1": 309.59999999999997, "x2": 516.96, "y1": 218.88, "y2": 320.15999999999997}}, {"filename": "../figure/image/952-Table5-1.png", "caption": "Table 5: Case studies on word clustering", "page": 8, "bbox": {"x1": 76.8, "x2": 285.12, "y1": 62.879999999999995, "y2": 168.0}}, {"filename": "../figure/image/952-Figure3-1.png", "caption": "Figure 3: An autoencoder for relation grouping.", "page": 4, "bbox": {"x1": 306.71999999999997, "x2": 526.0799999999999, "y1": 62.879999999999995, "y2": 132.0}}]}